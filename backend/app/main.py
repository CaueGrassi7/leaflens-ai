from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import numpy as np
from io import BytesIO
from PIL import Image
import tensorflow as tf
import json
from pathlib import Path

app = FastAPI()

# --- CONFIGURATION ---
CONFIDENCE_THRESHOLD = 0.70  # 70% minimum confidence for predictions

origins = [
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- PATH CONFIGURATION ---
# Define a versÃ£o do modelo que vocÃª quer usar (tem que bater com o que vocÃª usou no train.py)
MODEL_VERSION = "universal_v1"

# Resolve paths
BASE_DIR = Path(__file__).parent  # backend/app
PROJECT_ROOT = BASE_DIR.parent.parent  # leaflens-ai root
MODELS_DIR = PROJECT_ROOT / "ml" / "models"

MODEL_PATH = MODELS_DIR / f"plant_disease_model_v{MODEL_VERSION}.keras"
CLASSES_PATH = MODELS_DIR / f"classes_v{MODEL_VERSION}.json"

print(f"--- SYSTEM STARTUP ---")
print(f"ðŸ“‚ Project Root: {PROJECT_ROOT}")
print(f"ðŸ§  Loading Model Version: {MODEL_VERSION}")

# --- LOAD MODEL ---
try:
    # .resolve() ensures we have the absolute path for TensorFlow
    MODEL = tf.keras.models.load_model(str(MODEL_PATH.resolve()))
    print(f"âœ… Model loaded successfully from: {MODEL_PATH.name}")
except Exception as e:
    print(f"âŒ Critical Error loading model: {e}")
    MODEL = None

# --- LOAD CLASS NAMES DYNAMICALLY ---
# Instead of hardcoding, we read the JSON generated by the training script
try:
    with open(CLASSES_PATH.resolve(), "r") as f:
        CLASS_NAMES = json.load(f)
    print(f"âœ… Loaded {len(CLASS_NAMES)} classes from JSON.")
    # Print first 3 classes just to verify
    print(f"   Example: {CLASS_NAMES[:3]}...") 
except Exception as e:
    print(f"âŒ Critical Error loading classes JSON: {e}")
    print("Did you run the training script? Ensure 'classes_vX.json' exists.")
    CLASS_NAMES = []

@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "name": "LeafLens AI API",
        "version": "2.0.0", # Bumped version for Universal Support
        "model_version": MODEL_VERSION,
        "description": "API para detecÃ§Ã£o de doenÃ§as em mÃºltiplas culturas (Universal Model)",
        "endpoints": {
            "health": "/health",
            "predict": "/predict",
            "docs": "/docs",
            "redoc": "/redoc"
        },
        "status": {
            "model_loaded": MODEL is not None,
            "classes_loaded": len(CLASS_NAMES) > 0
        }
    }

@app.get("/health")
async def ping():
    if MODEL is None or not CLASS_NAMES:
        return {"status": "unhealthy", "reason": "Model or classes not loaded"}
    return {"status": "healthy", "classes_count": len(CLASS_NAMES)}

def read_file_as_image(data) -> np.ndarray:
    try:
        image = np.array(Image.open(BytesIO(data)))
        return image
    except Exception as e:
        raise HTTPException(status_code=400, detail="Invalid image file")

@app.post("/predict")
async def predict(file: UploadFile = File(...)):
    # Fail fast if system is not ready
    if MODEL is None:
        raise HTTPException(status_code=500, detail="Model is not loaded.")
    if not CLASS_NAMES:
        raise HTTPException(status_code=500, detail="Class names not loaded.")
    
    image = read_file_as_image(await file.read())
    
    # Preprocessing: Expand dims (256,256,3) -> (1,256,256,3)
    img_batch = np.expand_dims(image, 0)
    
    # Inference
    predictions = MODEL.predict(img_batch)
    
    # Decoding result
    predicted_class_index = np.argmax(predictions[0])
    predicted_class = CLASS_NAMES[predicted_class_index]
    confidence = float(np.max(predictions[0]))
    
    # Check confidence threshold for "Open World" problem
    if confidence < CONFIDENCE_THRESHOLD:
        return {
            "class": "Unidentified",
            "confidence": confidence,
            "low_confidence": True,
            "message": f"Model confidence ({confidence:.0%}) was too low. The image may not be of a known plant."
        }
    
    # Return standard prediction for high confidence
    return {
        "class": predicted_class,
        "confidence": confidence
    }

if __name__ == "__main__":
    uvicorn.run(app, host="localhost", port=8000)
